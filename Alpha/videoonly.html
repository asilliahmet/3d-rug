<!DOCTYPE html>
<html>
  <head>
    <title>WebXR Depth Map Example</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.130.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.130.2/examples/js/loaders/GLTFLoader.js"></script>
  </head>
  <body>
    <script>
      // Check if WebXR is supported
      if ('xr' in navigator) {
        navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
          if (supported) {
            // Request AR session
            document.body.innerHTML = '<button onclick="startAR()">Start AR</button>';
            const canvas = document.createElement('canvas');
            canvas.style.display = 'none';
            document.body.appendChild(canvas);
            const gl = canvas.getContext('webgl', { xrCompatible: true });
            navigator.xr.requestSession('immersive-ar', { requiredFeatures: ['depth-sensing'] })
              .then((session) => {
                // Initialize renderer
                const renderer = new THREE.WebGLRenderer({
                  alpha: true,
                  preserveDrawingBuffer: true,
                  canvas: canvas,
                  context: gl
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);

                // Initialize camera and scene
                const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
                const scene = new THREE.Scene();
                const light = new THREE.AmbientLight(0xffffff);
                scene.add(light);

                // Load model
                const loader = new THREE.GLTFLoader();
                loader.load('model.glb', (gltf) => {
                  scene.add(gltf.scene);
                });

                // Initialize XR session
                session.addEventListener('end', () => {
                  window.location.reload();
                });
                session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });
                const xrReferenceSpaceType = 'local';
                let xrReferenceSpace = null;
                session.requestReferenceSpace(xrReferenceSpaceType).then((referenceSpace) => {
                  xrReferenceSpace = referenceSpace;
                });

                // Render loop
                function render(timestamp, xrFrame) {
                  session.requestAnimationFrame(render);

                  // Get depth map
                  const depthMap = xrFrame.getDepthInformation(xrReferenceSpace);

                  // Render scene
                  renderer.xr.enabled = true;
                  renderer.xr.setFramebuffer(depthMap.depthMapFramebuffer);
                  renderer.render(scene, camera);

                  // Send depth map to server for processing
                  sendDepthMap(depthMap.depthMap);

                  // Restore default framebuffer
                  renderer.xr.setFramebuffer(null);
                }

                // Start AR session and render loop
                function startAR() {
                  session.requestAnimationFrame(render);
                  session.requestReferenceSpace('viewer').then((referenceSpace) => {
                    session.requestAnimationFrame((time, frame) => {
                      xrReferenceSpace = referenceSpace.getOffsetReferenceSpace(new XRRigidTransform({ y: -1.5 }));
                    });
                  });
                }
              })
              .catch((error) => {
                console.error(error);
              });
          }
        });
      }

      // Send depth map to server for processing
      function sendDepthMap(depthMap) {
        const canvas = document.getElementById('depth-map');
  const ctx = canvas.getContext('2d');
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;

  // Normalize depth map to RGB
  for (let i = 0; i < data.length; i += 4) {
    const depth = data[i] / 255;
    const r = depth * 255;
    const g = depth * 255;
    const b = depth * 255;
    data[i] = r;
    data[i + 1] = g;
    data[i + 2] = b;
  }

  // Create a canvas element to hold the normalized depth map
  const rgbCanvas = document.createElement('canvas');
  rgbCanvas.width = canvas.width;
  rgbCanvas.height = canvas.height;
  const rgbCtx = rgbCanvas.getContext('2d');
  rgbCtx.putImageData(imageData, 0, 0);

  // Convert the canvas to a data URL and download it
  const downloadLink = document.createElement('a');
  downloadLink.href = rgbCanvas.toDataURL('image/png');
  downloadLink.download = 'depth-map.png';
  downloadLink.click();
      }
